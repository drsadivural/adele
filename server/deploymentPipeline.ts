/**
 * Deployment Pipeline for ADELE
 * Handles containerization and deployment of generated applications
 */

import { storagePut } from "./storage";
import * as db from "./db";

export interface DeploymentConfig {
  projectId: number;
  version: string;
  environment: "development" | "staging" | "production";
  envVars: Record<string, string>;
  resources?: {
    cpu?: string;
    memory?: string;
  };
}

export interface DeploymentStatus {
  id: number;
  status: "pending" | "building" | "deploying" | "live" | "failed" | "stopped";
  deploymentUrl?: string;
  buildLogs?: string;
  errorMessage?: string;
  startedAt?: Date;
  completedAt?: Date;
}

export interface PackagedApplication {
  zipUrl: string;
  dockerComposeUrl: string;
  readmeUrl: string;
  totalFiles: number;
  totalSize: number;
}

/**
 * Package generated files into a downloadable archive
 */
export async function packageApplication(
  projectId: number,
  projectName: string
): Promise<PackagedApplication> {
  // Get all generated files for the project
  const files = await db.getGeneratedFilesByProjectId(projectId);
  
  if (!files || files.length === 0) {
    throw new Error("No files to package");
  }

  // Create a combined markdown file with all code
  let combinedContent = `# ${projectName} - Generated Code\n\n`;
  combinedContent += `Generated by ADELE on ${new Date().toISOString()}\n\n`;
  combinedContent += `## Table of Contents\n\n`;
  
  // Add table of contents
  files.forEach((file, index) => {
    combinedContent += `${index + 1}. [${file.filePath}](#${file.filePath.replace(/[^a-zA-Z0-9]/g, '-')})\n`;
  });
  
  combinedContent += `\n---\n\n`;
  
  // Add each file's content
  let totalSize = 0;
  files.forEach(file => {
    combinedContent += `## ${file.filePath}\n\n`;
    combinedContent += `**Type:** ${file.category} | **File Type:** ${file.fileType}\n\n`;
    combinedContent += `\`\`\`${file.fileType}\n${file.content}\n\`\`\`\n\n`;
    combinedContent += `---\n\n`;
    totalSize += file.content.length;
  });

  // Upload to S3
  const timestamp = Date.now();
  const fileKey = `projects/${projectId}/exports/${projectName}-${timestamp}.md`;
  
  const { url: zipUrl } = await storagePut(
    fileKey,
    Buffer.from(combinedContent, 'utf-8'),
    'text/markdown'
  );

  // Generate Docker Compose content
  const dockerComposeContent = generateDockerCompose(projectName);
  const dockerKey = `projects/${projectId}/exports/docker-compose-${timestamp}.yml`;
  
  const { url: dockerComposeUrl } = await storagePut(
    dockerKey,
    Buffer.from(dockerComposeContent, 'utf-8'),
    'text/yaml'
  );

  // Generate README
  const readmeContent = generateReadme(projectName, files.length);
  const readmeKey = `projects/${projectId}/exports/README-${timestamp}.md`;
  
  const { url: readmeUrl } = await storagePut(
    readmeKey,
    Buffer.from(readmeContent, 'utf-8'),
    'text/markdown'
  );

  return {
    zipUrl,
    dockerComposeUrl,
    readmeUrl,
    totalFiles: files.length,
    totalSize
  };
}

/**
 * Create a deployment for a project
 */
export async function createDeployment(config: DeploymentConfig): Promise<DeploymentStatus> {
  // Create deployment record
  const deployment = await db.createDeployment({
    projectId: config.projectId,
    version: config.version,
    status: "pending",
    config: {
      environment: config.environment,
      envVars: config.envVars,
      resources: config.resources
    }
  });

  if (!deployment) {
    throw new Error("Failed to create deployment record");
  }

  // Start the deployment process (simulated)
  startDeploymentProcess(deployment.id, config);

  return {
    id: deployment.id,
    status: "pending",
    startedAt: new Date()
  };
}

/**
 * Simulate deployment process
 */
async function startDeploymentProcess(deploymentId: number, config: DeploymentConfig): Promise<void> {
  const buildLogs: string[] = [];
  
  try {
    // Phase 1: Building
    await db.updateDeployment(deploymentId, { status: "building" });
    buildLogs.push(`[${new Date().toISOString()}] Starting build process...`);
    buildLogs.push(`[${new Date().toISOString()}] Environment: ${config.environment}`);
    buildLogs.push(`[${new Date().toISOString()}] Version: ${config.version}`);
    
    // Simulate build time
    await sleep(2000);
    buildLogs.push(`[${new Date().toISOString()}] Build completed successfully`);

    // Phase 2: Deploying
    await db.updateDeployment(deploymentId, { 
      status: "deploying",
      buildLogs: buildLogs.join('\n')
    });
    buildLogs.push(`[${new Date().toISOString()}] Starting deployment...`);
    
    // Simulate deployment time
    await sleep(2000);
    buildLogs.push(`[${new Date().toISOString()}] Deployment completed`);

    // Phase 3: Live
    const deploymentUrl = `https://app-${config.projectId}-${config.version}.appforge.dev`;
    
    await db.updateDeployment(deploymentId, {
      status: "live",
      deploymentUrl,
      buildLogs: buildLogs.join('\n'),
      completedAt: new Date()
    });

    // Update project with deployment URL
    await db.updateProject(config.projectId, {
      status: "deployed",
      deploymentUrl
    });

    buildLogs.push(`[${new Date().toISOString()}] Application is now live at ${deploymentUrl}`);

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    buildLogs.push(`[${new Date().toISOString()}] ERROR: ${errorMessage}`);
    
    await db.updateDeployment(deploymentId, {
      status: "failed",
      errorMessage,
      buildLogs: buildLogs.join('\n')
    });

    await db.updateProject(config.projectId, {
      status: "failed"
    });
  }
}

/**
 * Stop a running deployment
 */
export async function stopDeployment(deploymentId: number): Promise<void> {
  await db.updateDeployment(deploymentId, {
    status: "stopped",
    completedAt: new Date()
  });
}

/**
 * Get deployment status
 */
export async function getDeploymentStatus(projectId: number): Promise<DeploymentStatus | null> {
  const deployment = await db.getLatestDeployment(projectId);
  
  if (!deployment) {
    return null;
  }

  return {
    id: deployment.id,
    status: deployment.status,
    deploymentUrl: deployment.deploymentUrl || undefined,
    buildLogs: deployment.buildLogs || undefined,
    errorMessage: deployment.errorMessage || undefined,
    completedAt: deployment.completedAt || undefined
  };
}

/**
 * Generate Docker Compose configuration
 */
function generateDockerCompose(appName: string): string {
  return `version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:8000
    depends_on:
      - backend
    restart: unless-stopped

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/${appName.toLowerCase()}
      - SECRET_KEY=\${SECRET_KEY:-change-me-in-production}
    depends_on:
      - db
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=${appName.toLowerCase()}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  default:
    name: ${appName.toLowerCase()}-network
`;
}

/**
 * Generate README for exported project
 */
function generateReadme(appName: string, fileCount: number): string {
  return `# ${appName}

Generated by ADELE - AI-Powered No-Code Application Builder

## Overview

This project was automatically generated based on your requirements. It includes:
- **${fileCount} files** generated
- Full-stack application with React frontend and FastAPI backend
- Docker configuration for easy deployment
- Database integration with PostgreSQL

## Quick Start

### Using Docker (Recommended)

1. Make sure Docker and Docker Compose are installed
2. Copy the environment template:
   \`\`\`bash
   cp .env.example .env
   \`\`\`
3. Start the application:
   \`\`\`bash
   docker-compose up -d
   \`\`\`
4. Access the application:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:8000
   - API Docs: http://localhost:8000/docs

### Manual Setup

#### Backend
\`\`\`bash
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\\Scripts\\activate
pip install -r requirements.txt
uvicorn main:app --reload
\`\`\`

#### Frontend
\`\`\`bash
cd frontend
npm install
npm run dev
\`\`\`

## Project Structure

\`\`\`
${appName}/
├── frontend/           # React TypeScript application
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── hooks/
│   │   └── App.tsx
│   └── package.json
├── backend/            # FastAPI Python application
│   ├── routers/
│   ├── models/
│   ├── main.py
│   └── requirements.txt
├── docker-compose.yml
└── README.md
\`\`\`

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| DATABASE_URL | PostgreSQL connection string | postgresql://postgres:postgres@localhost:5432/${appName.toLowerCase()} |
| SECRET_KEY | JWT signing key | (required) |
| API_HOST | Backend host | 0.0.0.0 |
| API_PORT | Backend port | 8000 |

## API Documentation

Once the backend is running, visit:
- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Deployment

### Cloud Deployment Options

1. **Docker-based**: Use the included docker-compose.yml
2. **Kubernetes**: Convert docker-compose to k8s manifests
3. **Serverless**: Deploy frontend to Vercel/Netlify, backend to AWS Lambda

## Support

This application was generated by ADELE. For questions or issues:
- Visit the ADELE documentation
- Contact support through the ADELE dashboard

## License

MIT License - Feel free to modify and distribute.
`;
}

/**
 * Helper function to sleep
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export default {
  packageApplication,
  createDeployment,
  stopDeployment,
  getDeploymentStatus
};
